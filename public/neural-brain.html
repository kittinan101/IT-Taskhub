<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Neural Network Brain</title>
<style>
  * { margin: 0; padding: 0; }
  body { background: #0a0a1a; overflow: hidden; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
}
resize();
addEventListener('resize', resize);

// Create neurons in brain-like shape (ellipse)
const neurons = [];
const NUM = 180;
for (let i = 0; i < NUM; i++) {
  // Generate points in ellipse shape
  const angle = Math.random() * Math.PI * 2;
  const rx = (0.15 + Math.random() * 0.25);
  const ry = (0.15 + Math.random() * 0.2);
  neurons.push({
    x: 0.5 + Math.cos(angle) * rx,
    y: 0.5 + Math.sin(angle) * ry,
    r: 1.5 + Math.random() * 2.5,
    vx: (Math.random() - 0.5) * 0.0003,
    vy: (Math.random() - 0.5) * 0.0003,
    pulse: Math.random() * Math.PI * 2,
    pulseSpeed: 0.01 + Math.random() * 0.03,
    layer: Math.floor(Math.random() * 4), // 0=input, 1-2=hidden, 3=output
  });
}

// Signals traveling along connections
const signals = [];

function addSignal(from, to) {
  signals.push({ from, to, t: 0, speed: 0.005 + Math.random() * 0.015 });
}

// Find connections (nearby neurons)
const connections = [];
for (let i = 0; i < NUM; i++) {
  for (let j = i + 1; j < NUM; j++) {
    const dx = (neurons[i].x - neurons[j].x) * W;
    const dy = (neurons[i].y - neurons[j].y) * H;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 120) {
      connections.push([i, j, dist]);
    }
  }
}

let time = 0;

function draw() {
  ctx.fillStyle = 'rgba(10, 10, 26, 0.15)';
  ctx.fillRect(0, 0, W, H);
  
  time++;
  
  // Random signal firing
  if (Math.random() < 0.15 && connections.length > 0) {
    const c = connections[Math.floor(Math.random() * connections.length)];
    addSignal(c[0], c[1]);
  }

  // Draw connections
  for (const [i, j, dist] of connections) {
    const a = neurons[i], b = neurons[j];
    const opacity = Math.max(0, 0.08 - dist / 2000);
    ctx.beginPath();
    ctx.moveTo(a.x * W, a.y * H);
    ctx.lineTo(b.x * W, b.y * H);
    ctx.strokeStyle = `rgba(80, 140, 255, ${opacity})`;
    ctx.lineWidth = 0.5;
    ctx.stroke();
  }

  // Draw and update signals
  for (let i = signals.length - 1; i >= 0; i--) {
    const s = signals[i];
    s.t += s.speed;
    if (s.t > 1) { signals.splice(i, 1); continue; }
    
    const a = neurons[s.from], b = neurons[s.to];
    const x = a.x + (b.x - a.x) * s.t;
    const y = a.y + (b.y - a.y) * s.t;
    const brightness = Math.sin(s.t * Math.PI);
    
    ctx.beginPath();
    ctx.arc(x * W, y * H, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(100, 200, 255, ${brightness * 0.9})`;
    ctx.fill();
    
    // Glow
    const grad = ctx.createRadialGradient(x * W, y * H, 0, x * W, y * H, 15);
    grad.addColorStop(0, `rgba(100, 200, 255, ${brightness * 0.3})`);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.fillRect(x * W - 15, y * H - 15, 30, 30);
    
    // Light up connection
    ctx.beginPath();
    ctx.moveTo(a.x * W, a.y * H);
    ctx.lineTo(b.x * W, b.y * H);
    ctx.strokeStyle = `rgba(100, 200, 255, ${brightness * 0.2})`;
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  // Draw neurons
  for (const n of neurons) {
    n.x += n.vx;
    n.y += n.vy;
    n.pulse += n.pulseSpeed;
    
    // Soft boundary
    if (n.x < 0.15 || n.x > 0.85) n.vx *= -1;
    if (n.y < 0.2 || n.y > 0.8) n.vy *= -1;
    
    const pulse = 0.5 + 0.5 * Math.sin(n.pulse);
    const colors = [
      [255, 100, 150], // input - pink
      [100, 180, 255], // hidden - blue
      [80, 220, 200],  // hidden - teal
      [255, 180, 80],  // output - orange
    ];
    const [cr, cg, cb] = colors[n.layer];
    
    // Glow
    const grad = ctx.createRadialGradient(n.x * W, n.y * H, 0, n.x * W, n.y * H, n.r * 6);
    grad.addColorStop(0, `rgba(${cr}, ${cg}, ${cb}, ${0.15 + pulse * 0.15})`);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.fillRect(n.x * W - n.r * 6, n.y * H - n.r * 6, n.r * 12, n.r * 12);
    
    // Core
    ctx.beginPath();
    ctx.arc(n.x * W, n.y * H, n.r * (0.8 + pulse * 0.4), 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${cr}, ${cg}, ${cb}, ${0.6 + pulse * 0.4})`;
    ctx.fill();
  }
  
  // Title
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.font = '14px monospace';
  ctx.fillText('neural network', 20, H - 20);

  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
